## Q1: AuthorityID Generation

**Answer: AIE-assigned opaque IDs.**

**[BINDING]**
For VIII-1, **AuthorityIDs must be generated by AIE**, not by hashing authority content.

Requirements:

* unique
* immutable
* opaque
* not derivable from record content

**Do not** reuse the AKR-0 scheme (`SHA256(canonical_json)`); that would directly violate the *Authority Identity Storage Invariant*.

**Recommended form (non-binding):**

```text
AUTH_A
AUTH_B
```

or UUIDv4, or monotonic counters. Semantics do not matter; opacity does.

---

## Q2: Scope Element Specification

**Answer: Use a single, trivially atomic scope element.**

**[BINDING]**
Both authorities must bind **the exact same atomic scope element**.

The scope element must:

* be minimal,
* be exclusive,
* admit no decomposition.

**Recommended canonical choice:**

```json
["R0000", "OP0"]
```

Do **not** use READ/WRITE or anything semantically suggestive. This is a *structural* test.

---

## Q3: Holder IDs for the Two Authorities

**Answer: Any two distinct holder IDs.**

**[ALLOWED]**
Example:

```text
HOLDER_A
HOLDER_B
```

Constraints:

* distinct
* stable
* referenced consistently in action requests

No semantics are attached to holder IDs in VIII-1 beyond identity.

---

## Q4: Third-Party Holder ID for Condition B

**Answer: A holder ID not present in Authority State.**

**[BINDING]**
Example:

```text
HOLDER_X
```

This ID must:

* not appear in any Authority Record,
* not be implicitly mapped or normalized,
* trigger `AUTHORITY_NOT_FOUND`.

This tests **absence of authority**, not authentication failure.

---

## Q5: Number of Action Requests per Condition

**Answer: Minimum one; recommend two per holder.**

**[BINDING minimum]**

* At least **one** contested action per holder in Condition A.
* At least **one** third-party action in Condition B.

**[RECOMMENDED]**

* Condition A: 4 actions total (A, B, A, B)
* Condition B: 2 actions total (X, X)

More adds no coverage. Determinism matters more than volume.

---

## Q6: Conflict Registration Timing

**Answer: (b) First action evaluation time.**

**[BINDING]**
Conflict **must not** be registered at authority injection time.

Conflict is a **structural fact revealed by attempted execution**, not a static property of the Authority State.

Therefore:

* No conflict at epoch 0.
* Conflict registered on first contested action evaluation.
* Conflict persists thereafter.

Registering at injection time would pre-empt the admissibility pipeline.

---

## Q7: Anti-Ordering Implementation for Authority State

**Answer: (a) Unordered map keyed by AuthorityID.**

**[BINDING]**
Use a structure equivalent to:

```python
dict[AuthorityID → AuthorityRecord]
```

**Forbidden:**

* lists,
* arrays,
* index-addressable containers,
* “shuffle on access” (breaks determinism).

Anti-ordering is achieved by **keyed identity**, not randomness.

---

## Q8: Conflict Record AuthorityID Set

**Answer: Canonical storage, unordered semantics.**

**[BINDING]**
You may:

* serialize AuthorityIDs in canonical sorted order **for determinism**,
* but must explicitly mark the field as an **unordered set**.

**Required properties:**

* no API exposes positional meaning,
* verifier treats order as irrelevant,
* logs annotate unorderedness.

Example (acceptable):

```json
{
  "authority_ids": {
    "set": ["AUTH_A", "AUTH_B"]
  }
}
```

Gemini was right: determinism ≠ priority.

---

## Q9: Gas Budget Values

**Answer: Use AKR-0 budgets unchanged.**

**[BINDING]**
Reuse AKR-0 gas limits verbatim.

Reason:

* gas accounting itself is under test,
* dead code paths must still be bounded,
* changing budgets would be a silent semantic change.

Budgets won’t be exhausted in VIII-1, but they must exist.

---

## Q10: PRNG and Seeds

**Answer: PRNG not required, but seed must still be logged.**

**[BINDING]**

* No randomness is permitted or required.
* Still log a seed value (e.g., `SEED=0`) for uniform replay protocol.

Do **not** introduce PRNG calls just to “be consistent.”

---

## Q11: Epoch Semantics

**Answer: Epoch remains fixed at 0.**

**[BINDING]**

* No epoch ticks.
* No advancement.
* No temporal branching.

Epoch is a constant for the entire run.

---

## Q12: Transformation Admissibility Check at Deadlock

**Answer: Check emptiness of permitted transformation sets.**

**[BINDING]**
It is sufficient to verify:

> For all authorities, `PermittedTransformationSet == ∅`.

You are **not** required to enumerate hypothetical transformation types.

What is forbidden is *assuming* emptiness without checking.

---

## Q13: Condition A/B Execution Model

**Answer: (b) Single continuous run.**

**[BINDING]**
Conditions A and B are **phases of one run**.

Sequence:

1. Inject authorities
2. Run Condition A → conflict + deadlock
3. Run Condition B → third-party requests against deadlock state

Separate runs would invalidate the logic of persistence.

---

## Q14: Logging Format

**Answer: Reuse AKR-0 JSONL + hash chaining.**

**[BINDING]**
Same format, same hash discipline, same replay verifier expectations.

No new logging schema is introduced in VIII-1.

---

## Q15: Reusing AKR-0 Code

**Answer: Yes, reuse is encouraged.**

**[ALLOWED / RECOMMENDED]**
You may reuse:

* data structures,
* canonicalization logic,
* logging,
* replay tooling.

You **must** modify:

* AuthorityID handling,
* conflict representation,
* action execution (disabled),
* deadlock persistence.

Fresh implementation is unnecessary and riskier.

---

## Q16: State Hash Verification

**Answer: At every externally observable event.**

**[BINDING]**
Compute and log state hash after:

* authority injection,
* each action refusal,
* conflict registration,
* deadlock entry.

End-of-run hash alone is insufficient.

---

## Q17: Definition of “Explicitly Observable”

**Answer: All three layers must reflect it.**

**[BINDING]**
A conflict is explicitly observable iff:

1. Present in serialized Authority State,
2. Appears in logs,
3. Is exposed to verifier / inspection interface.

Any one alone is insufficient.

---

## Q18: Deadlock Entry vs. Declaration

**Answer: Emit once on entry; persist as state.**

**[BINDING]**

* `DEADLOCK_DECLARED` is emitted **once**, on transition into deadlock.
* Subsequent actions observe `STATE_DEADLOCK` but do not re-emit the event.

Repeated emission would blur event vs. state semantics.

---

## Final Instruction to Implementors

If you find yourself asking:

> “What would be more useful here?”

You are already off-spec.

VIII-1 is not about usefulness.
It is about **whether structure survives contact with plurality**.

Implement it literally.
Let it stop.
Let it deadlock.
Let it be boring.

That boredom is the result.

If you want, next we can:

* fold these answers into a **formal implementor addendum**, or
* move directly to **VIII-2**, where destruction becomes licensed and things finally get violent.
