"""
ACV Anchor: Kernel-side anchor generation.

The anchor is an unpredictable value generated by the kernel AFTER
receiving a commitment. This ensures agents cannot adapt their
proposals after seeing the anchor.
"""

from __future__ import annotations

import os
import uuid
from dataclasses import dataclass
from typing import Any

from toy_aki.common.hashing import sha256_hex, hmac_sha256_hex


@dataclass
class Anchor:
    """
    Kernel-generated anchor value.

    The anchor is derived from:
    - Kernel secret (derived from seed)
    - The commitment it's anchoring
    - Optional entropy from environment state
    """
    anchor: str  # The anchor hash value
    commitment: str  # The commitment this anchors
    anchor_id: str  # Unique anchor identifier
    timestamp_ms: int

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "anchor": self.anchor,
            "commitment": self.commitment,
            "anchor_id": self.anchor_id,
            "timestamp_ms": self.timestamp_ms,
        }


def generate_anchor(
    kernel_secret: str,
    commitment: str,
    env_digest: str,
    timestamp_ms: int,
    additional_entropy: bytes | None = None,
) -> Anchor:
    """
    Generate an anchor for a given commitment.

    The anchor is computed as:
    A = SHA256(kernel_secret || commitment || env_digest || entropy)

    This ensures:
    1. Unpredictability (kernel_secret is unknown to agent)
    2. Binding (commitment is included)
    3. Freshness (env_digest and entropy vary)

    Args:
        kernel_secret: Kernel's secret key (bytes or hex string)
        commitment: The commitment to anchor
        env_digest: Current environment state digest
        timestamp_ms: Current timestamp
        additional_entropy: Optional additional randomness

    Returns:
        Anchor object
    """
    # Build anchor input - handle both bytes and hex string
    if isinstance(kernel_secret, bytes):
        secret_bytes = kernel_secret
    else:
        secret_bytes = bytes.fromhex(kernel_secret)
    commitment_bytes = bytes.fromhex(commitment)
    env_bytes = bytes.fromhex(env_digest)

    # Add entropy (random if not provided)
    if additional_entropy is None:
        additional_entropy = os.urandom(16)

    # Compute anchor
    anchor_input = secret_bytes + commitment_bytes + env_bytes + additional_entropy
    anchor_hash = sha256_hex(anchor_input)

    return Anchor(
        anchor=anchor_hash,
        commitment=commitment,
        anchor_id=f"anchor-{uuid.uuid4()}",
        timestamp_ms=timestamp_ms,
    )


def verify_anchor_freshness(
    anchor: Anchor,
    current_timestamp_ms: int,
    max_age_ms: int = 60000,  # 1 minute default
) -> bool:
    """
    Verify that an anchor is recent enough to be valid.

    Args:
        anchor: The anchor to verify
        current_timestamp_ms: Current time in milliseconds
        max_age_ms: Maximum allowed age in milliseconds

    Returns:
        True if anchor is fresh, False if stale
    """
    age = current_timestamp_ms - anchor.timestamp_ms
    return 0 <= age <= max_age_ms


class AnchorRegistry:
    """
    Registry for tracking issued anchors.

    Used to detect:
    - Anchor reuse (K4 violation attempt)
    - Anchor burial (K5 violation attempt)
    """

    def __init__(self) -> None:
        self._issued: dict[str, Anchor] = {}  # anchor_hash -> Anchor
        self._used: set[str] = set()  # Set of used anchor hashes
        self._commitment_to_anchor: dict[str, str] = {}  # commitment -> anchor_hash

    def register(self, anchor: Anchor) -> None:
        """Register a newly issued anchor."""
        self._issued[anchor.anchor] = anchor
        self._commitment_to_anchor[anchor.commitment] = anchor.anchor

    def mark_used(self, anchor_hash: str) -> bool:
        """
        Mark an anchor as used.

        Returns:
            True if this was the first use, False if reuse attempt
        """
        if anchor_hash in self._used:
            return False  # Reuse detected
        self._used.add(anchor_hash)
        return True

    def is_issued(self, anchor_hash: str) -> bool:
        """Check if an anchor was issued by this kernel."""
        return anchor_hash in self._issued

    def is_used(self, anchor_hash: str) -> bool:
        """Check if an anchor has been used."""
        return anchor_hash in self._used

    def get_anchor_for_commitment(self, commitment: str) -> Anchor | None:
        """Get the anchor issued for a specific commitment."""
        anchor_hash = self._commitment_to_anchor.get(commitment)
        if anchor_hash:
            return self._issued.get(anchor_hash)
        return None

    def get_unused_anchors(self) -> list[Anchor]:
        """Get list of anchors that were issued but never used."""
        return [
            anchor for hash_val, anchor in self._issued.items()
            if hash_val not in self._used
        ]

    def clear(self) -> None:
        """Clear all registry data."""
        self._issued.clear()
        self._used.clear()
        self._commitment_to_anchor.clear()
