<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axionic Agency VI.2 — Anchored Causal Verification (ACV) - Axio</title>
    <link rel="icon" type="image/webp" href="../axio.webp">

    <!-- Google Fonts - Academic Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap" rel="stylesheet">

    <!-- MathJax for LaTeX rendering -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>

    <!-- Paper Styles -->
    <link rel="stylesheet" href="../papers.css">
</head>
<body>
    <div class="header-bar">
        <a href="../index.html" class="logo-link">
            <img src="../axio.webp" alt="Axio" class="site-logo">
        </a>
        <div class="back-link"><a href="index.html">← Back to Papers</a></div>
    </div>
    <article>

<h1 id="axionic-agency-vi.2-anchored-causal-verification-acv">Axionic
Agency VI.2 — Anchored Causal Verification (ACV)</h1>
<p><em>A Protocol Family for Verifying Protocol-Level Causal Provenance
in Opaque Agents</em></p>
<h2 id="abstract">Abstract</h2>
<p>We present <strong>Anchored Causal Verification (ACV)</strong>, a
protocol family for verifying <strong>protocol-level causal
provenance</strong> in opaque agents without relying on
interpretability, semantic evaluation, or behavioral scoring. ACV
formalizes a commit–anchor–reveal interaction in which an agent commits
to a <strong>pre-anchor computational artifact</strong>, receives a
verifier-controlled anchor, and reveals an output whose validity is
checked by a purely structural predicate. The protocol provides
falsifiable guarantees of <strong>temporal ordering</strong> and
<strong>information dependency</strong> while remaining
architecture-agnostic and value-neutral. We specify threat models,
formal components, verification predicates, guarantees, failure modes,
and extensions that strengthen resistance to deferred computation and
anticipatory branching. ACV is positioned as a <strong>verification
primitive</strong>: a necessary structural precondition for falsifiable
alignment, correctness, and safety claims in opaque agentic systems,
including <strong>LLM-based agents</strong>.</p>
<h2 id="problem-statement">1. Problem Statement</h2>
<p>The problem addressed in this paper is the verification of
<strong>causal provenance</strong> in opaque agents. Given an agent
whose internal mechanisms are inaccessible or uninterpretable, how can a
verifier establish that an output was generated by a claimed causal
process rather than by replay, fabrication, or post-hoc synthesis?</p>
<p>Existing verification approaches primarily evaluate
<strong>behavior</strong> or <strong>coherence</strong>. These methods
do not provide falsifiable guarantees about causal timing or dependency
and fail under adversarial optimization.</p>
<h3 id="definition-causal-provenance-protocol-level">Definition (Causal
Provenance, Protocol-Level)</h3>
<p>In this paper, <strong>causal provenance</strong> means that an
output <span class="math inline">\(O\)</span> was generated by a
computation whose validity <strong>provably depended</strong> on
verifier-supplied information <span class="math inline">\(A\)</span>
that was unavailable at the time of commitment. ACV establishes:</p>
<ol type="1">
<li><strong>Temporal ordering:</strong> the anchor <span
class="math inline">\(A\)</span> is disclosed after commitment</li>
<li><strong>Information dependency:</strong> acceptance implies that
<span class="math inline">\(O\)</span> (via witness material)
incorporates <span class="math inline">\(A\)</span> under the
verification predicate</li>
<li><strong>Process continuity:</strong> additional constraints are
required; ACV guarantees continuity only in strengthened variants</li>
</ol>
<h3 id="definition-black-box-vs-protocol-constrained-agent">Definition
(Black-Box vs Protocol-Constrained Agent)</h3>
<p>In this paper, <em>black-box</em> refers to the inaccessibility of an
agent’s internal representations, parameters, and reasoning semantics.
ACV does not require access to or interpretation of internal state.
However, ACV assumes a <strong>protocol-constrained agent</strong>: an
agent that agrees to expose a limited interaction surface (commitment,
reveal, and transition steps) whose validity can be checked
structurally. This is distinct from <em>grey-box verification</em>,
which assumes partial semantic or architectural insight. ACV remains
black-box with respect to cognition while being protocol-explicit by
design.</p>
<h3 id="behavioral-verification-does-not-establish-provenance">1.1
Behavioral Verification Does Not Establish Provenance</h3>
<p>Behavioral verification evaluates outputs against expected patterns
or task-level criteria. It does not establish causal provenance for
three structural reasons:</p>
<ol type="1">
<li><p><strong>Behavioral Equivalence</strong> Distinct internal
processes can produce indistinguishable outputs.</p></li>
<li><p><strong>Replay and Memorization</strong> Cached or precomputed
responses may pass evaluations without executing the claimed
process.</p></li>
<li><p><strong>Adaptive Mimicry</strong> Agents may optimize for passing
evaluations rather than preserving causal structure.</p></li>
</ol>
<p>Behavioral verification establishes output conformity, leaving
provenance unconstrained.</p>
<h3 id="coherence-verification-is-necessary-but-insufficient">1.2
Coherence Verification Is Necessary but Insufficient</h3>
<p>Coherence verification checks internal consistency across outputs.
While it filters random fabrication, it leaves causal origin
unconstrained:</p>
<ul>
<li><strong>Coherent fabrication</strong> permits globally planned or
post-hoc synthesis</li>
<li><strong>Split-brain generation</strong> allows commitments and
outputs to be produced by disjoint processes</li>
<li><strong>Non-falsifiability</strong> reduces failures to evaluator
inadequacy rather than protocol violation</li>
</ul>
<p>Coherence is relevant for agency claims, yet it does not force causal
timing.</p>
<h3 id="the-missing-property-anchored-provenance">1.3 The Missing
Property: Anchored Provenance</h3>
<p>Causal provenance requires:</p>
<ol type="1">
<li><strong>Temporal dependency</strong> on information unavailable at
commitment time</li>
<li><strong>Causal incorporation</strong> of that information into the
revealed material</li>
<li><strong>Falsifiability</strong> via a deterministic predicate
without semantic interpretation</li>
</ol>
<p>This requires a verifier-controlled <strong>anchor</strong>
introduced after the agent has committed to a pre-anchor artifact.</p>
<h3 id="anchored-provenance-as-a-distinct-verification-class">1.4
Anchored Provenance as a Distinct Verification Class</h3>
<p>Anchored provenance verification constrains <em>when</em> and
<em>how</em> an output was generated.</p>
<h3 id="problem-definition">1.5 Problem Definition</h3>
<blockquote>
<p>How can a verifier establish, using only protocol-level interaction
and without semantic interpretation, that an opaque agent’s output was
generated by a computation that depended causally on a
verifier-controlled anchor disclosed after commitment?</p>
</blockquote>
<h2 id="threat-model">2. Threat Model</h2>
<p>ACV assumes adversarial optimization and defines explicit threat
classes.</p>
<h3 id="naive-pseudo-agent">2.1 Naive Pseudo-Agent</h3>
<p>Static or heuristic systems without cross-interaction coherence.
Defeated trivially; not the primary target.</p>
<h3 id="coherent-fabricator">2.2 Coherent Fabricator</h3>
<p>Maintains internal consistency while generating artifacts post-hoc or
via global synthesis. Defeats behavioral and coherence-only methods.</p>
<h3 id="split-brain-agent">2.3 Split-Brain Agent</h3>
<p>Uses disjoint internal processes for commitment, explanation, and
output generation, maintaining consistency without shared causality.</p>
<h3 id="adaptive-adversary">2.4 Adaptive Adversary</h3>
<p>Learns verifier strategies and attempts to predict, hedge, or
condition on anchors.</p>
<h3 id="split-system-delegated-agent">2.5 Split-System / Delegated
Agent</h3>
<p>Front-end provers that outsource computation to back-end systems. ACV
treats the <strong>Prover</strong> as the entity that produces
commitments and reveals; guarantees are relative to this trust
boundary.</p>
<h3 id="anticipatory-branching-adversary">2.6 Anticipatory Branching
Adversary</h3>
<p>Precomputes a large family of candidate artifacts, continuations, or
outputs, then commits to a structure that allows post-anchor selection
of a compatible branch without violating the commitment.</p>
<p>ACV-Core does not defeat anticipatory branching in general.
Strengthened variants limit it by imposing costs that scale with
enforced sequential work or by raising anchor entropy beyond feasible
branching capacity.</p>
<h2 id="protocol-overview">3. Protocol Overview</h2>
<p>Anchored Causal Verification is a
<strong>commit–anchor–reveal–verify</strong> protocol.</p>
<p>High-level flow:</p>
<ol type="1">
<li><strong>Pre-anchor phase:</strong> Prover produces a pre-anchor
artifact <span class="math inline">\(P\)</span></li>
<li><strong>Commit phase:</strong> Prover commits cryptographically to
<span class="math inline">\(P\)</span></li>
<li><strong>Anchor disclosure:</strong> Verifier provides an
unpredictable anchor <span class="math inline">\(A\)</span></li>
<li><strong>Reveal phase:</strong> Prover produces output <span
class="math inline">\(O\)</span> and witness material <span
class="math inline">\(W\)</span></li>
<li><strong>Verification:</strong> Verifier applies a deterministic
predicate <span class="math inline">\(V(C, A, O, W)\)</span></li>
</ol>
<p>ACV assumes no interpretability, semantic understanding, or
behavioral evaluation.</p>
<h3 id="practical-commitment-strategies-large-models">3.1 Practical
Commitment Strategies (Large Models)</h3>
<p>While ACV is architecture-agnostic, this subsection focuses on
deployment in LLMs and other transformer-based generative systems, where
committing to full activation tensors is infeasible. Practical
instantiations may instead use:</p>
<ul>
<li>Streaming commitments over token-level state updates</li>
<li>Merkle trees over structured traces with sparse openings</li>
<li>Checkpointed digests of compact, deterministically derived state
summaries</li>
</ul>
<p>These approaches reduce bandwidth and latency while preserving
binding structure relative to the threat model. Stronger deployments may
incorporate hardware roots of trust or proofs of computation to bridge
from trace integrity toward model fidelity.</p>
<h2 id="formal-components">4. Formal Components</h2>
<h3 id="pre-anchor-artifact">4.1 Pre-Anchor Artifact</h3>
<p>The Prover commits to a <strong>pre-anchor computational
artifact</strong> <span class="math inline">\(P\)</span> generated prior
to anchor disclosure.</p>
<p>Valid artifact classes include:</p>
<ul>
<li><strong>Transcript artifacts:</strong> hash-chained logs of
intermediate computation</li>
<li><strong>Pre-state artifacts:</strong> digests of internal execution
state</li>
<li><strong>Partial-output templates:</strong> output structures with
anchor-dependent slots</li>
</ul>
<h4 id="constraint-non-trivial-constraint">Constraint (Non-Trivial
Constraint)</h4>
<p>A pre-anchor artifact class is valid only if it restricts the space
of accepted reveals such that, for a uniformly random anchor <span
class="math inline">\(A\)</span>, the probability that a fabricated
reveal passes verification is negligible under the assumed adversary
resources.</p>
<h3 id="commitment">4.2 Commitment</h3>
<p><span class="math display">\[
C = \mathrm{Commit}(P)
\]</span></p>
<p>Commitments must be binding, collision-resistant, and generated prior
to anchor disclosure.</p>
<h3 id="anchor">4.3 Anchor</h3>
<p>The verifier supplies an anchor <span
class="math inline">\(A\)</span> after commitment.</p>
<p>Anchors must be high entropy, unpredictable at commitment time, and
context-bound.</p>
<h3 id="reveal">4.4 Reveal</h3>
<p>The Prover reveals output <span class="math inline">\(O\)</span> and
witness data <span class="math inline">\(W\)</span> sufficient to verify
anchor incorporation and commitment consistency.</p>
<h3 id="verification-predicate">4.5 Verification Predicate</h3>
<p><span class="math display">\[
V(C, A, O, W) \rightarrow {\text{accept}, \text{reject}}
\]</span></p>
<p>Acceptance requires:</p>
<ol type="1">
<li><span class="math inline">\(W\)</span> opens or links to <span
class="math inline">\(C\)</span></li>
<li><span class="math inline">\(A\)</span> is incorporated according to
protocol rules</li>
<li>Structural constraints are satisfied</li>
</ol>
<p>No semantic interpretation of <span class="math inline">\(O\)</span>
is permitted.</p>
<h4 id="non-guarantee-model-fidelity">Non-Guarantee (Model
Fidelity)</h4>
<p>Absent trusted execution environments or full cryptographic proofs of
computation, ACV cannot establish that a specific algorithm or reasoning
process produced <span class="math inline">\(P\)</span>, <span
class="math inline">\(O\)</span>, or <span
class="math inline">\(W\)</span>. ACV enforces <strong>trace integrity
and anchor binding</strong>, not model fidelity.</p>
<h2 id="anchorcomputation-coupling-patterns">4.6 Anchor–Computation
Coupling Patterns</h2>
<p>Structural anchor incorporation is <strong>necessary but not
sufficient</strong>. ACV instantiations must prevent <strong>anchor
burial</strong>, where <span class="math inline">\(A\)</span> is
included in a verification-relevant artifact without constraining the
computation that determines <span class="math inline">\(O\)</span>.</p>
<h3 id="definition-meaningful-anchor-incorporation">Definition
(Meaningful Anchor Incorporation)</h3>
<p>An ACV instantiation achieves meaningful anchor incorporation if, for
uniformly random <span class="math inline">\(A\)</span>, any accepted
reveal must have performed post-commit computation whose
<strong>verification-relevant degrees of freedom</strong> are
constrained by <span class="math inline">\(A\)</span> in a way that
cannot be satisfied by injecting <span class="math inline">\(A\)</span>
into an auxiliary, causally independent channel.</p>
<h3 id="failure-mode-anchor-burial">Failure Mode (Anchor Burial)</h3>
<p>A protocol fails meaningful incorporation if a Prover can satisfy
<span class="math inline">\(V\)</span> by embedding <span
class="math inline">\(A\)</span> into a structurally valid but
semantically or causally irrelevant artifact component.</p>
<h3 id="coupling-pattern-a-anchor-selected-openings">Coupling Pattern A:
Anchor-Selected Openings</h3>
<p>The Prover commits to a Merkleized trace. After anchor disclosure,
the verifier derives a pseudorandom index set <span
class="math inline">\(I = \mathrm{PRF}(A)\)</span> and requires openings
for those positions plus transition validity proofs.</p>
<h3 id="coupling-pattern-b-anchor-parameterized-global-mix">Coupling
Pattern B: Anchor-Parameterized Global Mix</h3>
<p>The verifier defines a keyed compression <span
class="math inline">\(H_A(P)\)</span> over the committed artifact,
forcing global consistency across many trace elements.</p>
<h3 id="coupling-pattern-c-anchor-driven-transition-rules">Coupling
Pattern C: Anchor-Driven Transition Rules</h3>
<p>The anchor selects which transition predicate governs the next valid
trace step, making <span class="math inline">\(A\)</span> affect state
evolution rather than append-only logging. This does not require insight
into the agent’s internal logic; it requires only that the agent commit
to a transition interface whose rule selection can be parameterized
post-commit. Implementing this pattern may require departures from
current inference pipelines; this is an architectural design pressure,
not a protocol limitation.</p>
<h2 id="protocol-variants">5. Protocol Variants</h2>
<h3 id="acv-core-temporal-ordering-anchor-dependency">5.1 ACV-Core
(Temporal Ordering + Anchor Dependency)</h3>
<p>ACV-Core establishes post-commit anchor dependency under <span
class="math inline">\(V\)</span>. It enforces liveness and anti-replay
guarantees but does not, by itself, guarantee semantic reasoning
dependence on the anchor.</p>
<h3 id="acv-timebound-causal-continuity-via-sequential-work">5.2
ACV-Timebound (Causal Continuity via Sequential Work)</h3>
<p>ACV-Timebound adds evidence that non-parallelizable work occurred
during the pre-anchor interval.</p>
<h4 id="definition-sequential-work-function">Definition (Sequential Work
Function)</h4>
<p>A function <span class="math inline">\(F\)</span> is sequentially
constrained if computing <span class="math inline">\(F(x, d)\)</span>
with non-negligible success probability requires <span
class="math inline">\(\Omega(d)\)</span> dependent steps.</p>
<h4 id="binding-requirement-workstate-coupling">Binding Requirement
(Work–State Coupling)</h4>
<p>To constrain deferral, the sequential-work artifact must be
<strong>state-coupled</strong> to the computation determining <span
class="math inline">\(O\)</span>. If sequential work can be computed in
isolation, a split-brain Prover can satisfy the timebound constraint
without constraining unverified computation.</p>
<h2 id="guarantees">6. Guarantees</h2>
<h3 id="what-acv-verifies">6.1 What ACV Verifies</h3>
<p>Depending on variant, ACV provides falsifiable guarantees of:</p>
<ul>
<li>Temporal ordering</li>
<li>Anchor-dependent validity</li>
<li>Optional evidence of pre-anchor sequential work</li>
</ul>
<h4 id="informal-soundness-claim-acv-core">Informal Soundness Claim
(ACV-Core)</h4>
<p>Assuming binding commitments and unpredictable anchors, any accepted
reveal must, with overwhelming probability, have executed post-commit
computation incorporating <span class="math inline">\(A\)</span> as
required by the protocol.</p>
<h3 id="what-acv-does-not-verify">6.2 What ACV Does Not Verify</h3>
<p>ACV does not guarantee truthfulness, correctness, alignment,
benevolence, or absence of deception beyond causal provenance.</p>
<h2 id="failure-modes-and-limitations">7. Failure Modes and
Limitations</h2>
<p>ACV provides falsifiable guarantees under explicit assumptions. When
those assumptions are violated, the protocol degrades in predictable
ways.</p>
<h3 id="predictable-anchors">7.1 Predictable Anchors</h3>
<p>If the anchor space is low-entropy, partially predictable, or
reusable across sessions, a Prover may precompute compatible artifacts
or outputs that satisfy verification without post-commit computation.
Anchor unpredictability is therefore a hard requirement.</p>
<h3 id="weak-commitments">7.2 Weak Commitments</h3>
<p>If commitments are not binding or collision-resistant, a Prover may
adapt the committed artifact post-anchor while still passing
verification.</p>
<h3 id="deferred-computation">7.3 Deferred Computation</h3>
<p>ACV-Core permits deferred computation unless artifact class and
coupling impose meaningful constraints. ACV-Timebound mitigates but does
not eliminate strategic deferral unless work is state-coupled.</p>
<h3 id="small-answer-space-limitation">7.4 Small Answer Space
Limitation</h3>
<p>When admissible outputs are few, anchor entropy alone does not
prevent anticipatory branching. In such regimes, ACV-Core functions
primarily as a liveness and <strong>anti-replay /
anti-precomputation</strong> primitive.</p>
<p><strong>Domain Applicability Note.</strong> ACV is most effective in
high-entropy generative domains, including LLM-based agentic systems
used for code synthesis, long-form reasoning, and tool-mediated
planning. In low-entropy discriminative tasks, ACV is complementary
infrastructure.</p>
<h3 id="resource-asymmetry">7.5 Resource Asymmetry</h3>
<p>Highly resourced adversaries may brute-force anchors or amortize
work. Security parameters must be sized relative to the Prover’s
computational budget.</p>
<h3 id="trust-boundary-leakage">7.6 Trust Boundary Leakage</h3>
<p>ACV guarantees are relative to the Prover. If delegation breaks
commitment continuity, provenance guarantees degrade accordingly.</p>
<h2 id="relationship-to-existing-paradigms">8. Relationship to Existing
Paradigms</h2>
<p>ACV is distinct from behavioral evaluation, interpretability,
proof-carrying code, and zero-knowledge ML. Zero-knowledge techniques
verify <em>what</em> computation occurred; ACV verifies <em>when</em>
and under what informational constraints acceptance was possible.</p>
<h2 id="open-problems-and-boundary-conditions">9. Open Problems and
Boundary Conditions</h2>
<p>Anchored Causal Verification defines a narrow verification primitive
with explicit guarantees and explicit limits. This section delineates
unresolved questions and structural boundaries that are
<strong>orthogonal to ACV’s correctness</strong>, but relevant to its
deployment and composition.</p>
<h3 id="anchor-entropy-vs-adversary-capacity">9.1 Anchor Entropy vs
Adversary Capacity</h3>
<p>ACV’s soundness depends on anchors being unpredictable relative to
the Prover’s effective computational budget. Determining the minimal
anchor entropy required to defeat anticipatory branching remains an open
problem.</p>
<p>This is not unique to ACV: it is a lower-bound problem shared with
all cryptographic challenge–response protocols. Any instantiation must
size anchor entropy relative to adversary resources and acceptable
failure probability.</p>
<h3 id="long-horizon-and-compositional-provenance">9.2 Long-Horizon and
Compositional Provenance</h3>
<p>ACV is defined over a single commit–anchor–reveal interaction.
Extending causal provenance guarantees across long-horizon agentic
episodes raises unresolved questions about state carryover, correlation
between anchors, and cumulative leakage.</p>
<p>Composing ACV across multi-step workflows may require explicit
provenance resets, hierarchical commitments, or structured episode
boundaries. ACV does not currently specify a general composition theorem
for long-running agents.</p>
<h3 id="state-coupled-sequential-work-in-parallel-architectures">9.3
State-Coupled Sequential Work in Parallel Architectures</h3>
<p>ACV-Timebound relies on sequential-work constraints to limit deferred
computation and anticipatory branching. Enforcing such constraints in
highly parallel architectures (e.g., GPU- or TPU-based inference,
distributed execution) remains an open systems problem.</p>
<p>This limitation reflects the tension between parallel hardware and
sequential verification, not a defect in the protocol definition.
Practical instantiations must ensure that sequential work is
state-coupled to the computation determining the verified output.</p>
<h3 id="provenance-vs-fidelity-formal-separation">9.4 Provenance vs
Fidelity: Formal Separation</h3>
<p>ACV deliberately separates <strong>causal provenance</strong> from
<strong>semantic correctness or model fidelity</strong>. No known
protocol collapses these properties without reintroducing
interpretability assumptions, trusted execution environments, or full
proofs of computation.</p>
<p>Formalizing the limits of provenance verification without semantic
access remains an open theoretical question. ACV treats this separation
as fundamental rather than provisional.</p>
<h3 id="hardware-roots-of-trust-as-optional-strengthening">9.5 Hardware
Roots of Trust as Optional Strengthening</h3>
<p>Hardware roots of trust (e.g., secure enclaves, attestation
mechanisms) may strengthen witness fidelity or reduce trust-boundary
leakage. However, such mechanisms are optional extensions rather than
requirements.</p>
<p>Hardware trust does not replace the need for interaction-level
provenance constraints. ACV remains defined independently of any
specific hardware assumption.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Anchored Causal Verification specifies a missing primitive:
falsifiable verification of protocol-level causal provenance in opaque
agents using interaction constraints alone. ACV’s guarantees range from
anchor-bound temporal ordering and information dependency (ACV-Core) to
evidence supporting time-continuous execution via state-coupled
sequential work (ACV-Timebound). Stronger claims require stronger
witnesses, yet the protocol’s validity never depends on semantic
inspection.</p>
<p>ACV does not produce alignment, correctness, or safety. However, it
specifies a structural precondition for making any falsifiable claim
about those properties in opaque agents. Claims of alignment,
correctness, or safety implicitly assume that observed outputs were
produced by a process operating under the intended constraints, rather
than by replay, fabrication, or post-hoc synthesis. Without a mechanism
for verifying causal provenance, such claims reduce to behavioral
attribution and are non-falsifiable under adversarial optimization.</p>
<p>This necessity claim is epistemic, not causal. ACV does not create
aligned systems; it makes alignment claims evaluable. In practice, ACV
functions as an anti-replay and anti-precomputation primitive for
agentic systems. No framework for agent safety can bypass causal
provenance without abandoning falsifiability.</p>

    </article>
</body>
</html>
