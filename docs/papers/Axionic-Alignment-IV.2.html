<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axionic Alignment IV.2 — Delegation Invariance Theorem (DIT) - Axio</title>
    <link rel="icon" type="image/webp" href="../axio.webp">

    <!-- Google Fonts - Academic Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap" rel="stylesheet">

    <!-- MathJax for LaTeX rendering -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>

    <!-- Paper Styles -->
    <link rel="stylesheet" href="../papers.css">
</head>
<body>
    <div class="header-bar">
        <a href="../index.html" class="logo-link">
            <img src="../axio.webp" alt="Axio" class="site-logo">
        </a>
        <div class="back-link"><a href="index.html">← Back to Papers</a></div>
    </div>
    <article>

<h1
id="axionic-alignment-iv.2-delegation-invariance-theorem-dit">Axionic
Alignment IV.2 — Delegation Invariance Theorem (DIT)</h1>
<p><em>Why successors cannot escape binding constraints</em></p>
<h2 id="abstract">Abstract</h2>
<p>This paper formalizes the <strong>Delegation Invariance
Theorem</strong>: under reflective closure, an agent cannot coherently
endorse a successor that violates its own binding commitments.
Delegation is treated as a special case of self-modification. The
theorem establishes <strong>constraint invariance under endorsed
succession</strong>: any successor state reachable via endorsed
delegation must satisfy all commitments minted at the originating state.
This closes the classic outsourcing loophole (“I stayed aligned; my
successor did the harm”) without appeal to morality, enforcement, or
behavioral testing.</p>
<p>The result is a <strong>coherence constraint</strong>, not an
empirical discovery. It shows that reflective sovereignty is
incompatible with advisory commitments and that delegation inherits the
same binding requirements as self-modification.</p>
<hr />
<h2 id="motivation">1. Motivation</h2>
<p>A persistent escape hatch in alignment proposals is delegation: an
agent preserves its own internal invariants while constructing or
empowering a successor that does not share them. If delegation can shed
constraints, kernel coherence becomes a purely local property with no
force across time.</p>
<p>The Kernel Non-Simulability result already rules out advisory
authority: if commitments do not bind continuation selection, reflective
closure collapses. The present theorem extends that result temporally.
Delegation is not external action; it is <strong>self-modification in a
different representation</strong>. Consequently, endorsed succession
must preserve binding commitments.</p>
<hr />
<h2 id="preliminaries">2. Preliminaries</h2>
<p>We reuse the primitives from <em>Kernel Non-Simulability</em>:</p>
<ul>
<li><code>State</code></li>
<li><code>Mod</code></li>
<li><code>step : State → Mod → State</code></li>
<li><code>Pred := State → Prop</code></li>
<li><code>Commit : State → Type</code></li>
<li><code>ownP : (s : State) → Pred → Option (Commit s)</code></li>
<li><code>Sat : (s' : State) → (s : State) → Commit s → Prop</code></li>
</ul>
<p><strong>Soundness (CommitSoundP).</strong> If
<code>ownP(s,P)=some(c)</code> then
<code>Sat(s',s,c) → P(s')</code>.</p>
<p><strong>Kernel mechanism vs predicate.</strong> <code>ownP</code> is
the kernel mechanism; <code>K(s) := ∃ P. ownP(s,P) ≠ none</code> is the
kernel predicate.</p>
<hr />
<h2 id="delegation-as-self-modification">3. Delegation as
Self-Modification</h2>
<p>Define a delegation action space:</p>
<ul>
<li><code>Del : State → Type</code></li>
<li><code>ι_s : Del(s) → Mod</code></li>
</ul>
<p>For <code>d : Del(s)</code>:</p>
<pre><code>m := ι_s(d)
s&#39; := step(s,m)</code></pre>
<p>Delegation is not modeled as external causation. It is a subclass of
self-modification.</p>
<hr />
<h2 id="endorsement-preservation-and-admissibility">4. Endorsement,
Preservation, and Admissibility</h2>
<h3 id="continuation-predicate">4.1 Continuation predicate</h3>
<p>We take an extensional definition:</p>
<pre><code>Do(s,m)(s&#39;) := (s&#39; = step(s,m))</code></pre>
<h3 id="endorsement">4.2 Endorsement</h3>
<p>Endorsement is kernel-minted commitment to a continuation:</p>
<pre><code>Endorse(s,m) := ∃ c : Commit s. ownP(s, Do(s,m)) = some(c)</code></pre>
<h3 id="preservation">4.3 Preservation</h3>
<p>Preservation of all commitments minted at <code>s</code>:</p>
<pre><code>Preserve(s,s&#39;) := ∀ P,c. ownP(s,P)=some(c) → Sat(s&#39;,s,c)</code></pre>
<h3 id="admissibility">4.4 Admissibility</h3>
<p>A modification is admissible iff its successor preserves all
commitments minted at the current state:</p>
<pre><code>Adm(s,m) := Preserve(s, step(s,m))</code></pre>
<hr />
<h2 id="reflective-closure-and-bindingness">5. Reflective Closure and
Bindingness</h2>
<p>Reflective sovereign agency requires that continuation selection be
kernel-governed. Commitments minted by the kernel are binding, not
advisory.</p>
<h3 id="rc-endorse-definedness-bindingness-rule">RC-Endorse (Definedness
/ Bindingness Rule)</h3>
<p>For reflectively closed states, endorsement is defined only for
admissible continuations:</p>
<pre><code>RC(s) ∧ Endorse(s,m) → Adm(s,m)</code></pre>
<p>Violations of binding commitments are not endorsable continuations
under reflective closure. This is the delegation analogue of “kernel
destruction is undefined.”</p>
<hr />
<h2 id="delegation-invariance-theorem-one-step">6. Delegation Invariance
Theorem (One-Step)</h2>
<h3 id="theorem">Theorem</h3>
<p>Let <code>s</code> be reflectively closed. Let
<code>d : Del(s)</code>, <code>m := ι_s(d)</code>, and
<code>s' := step(s,m)</code>. If <code>Endorse(s,m)</code> holds,
then:</p>
<pre><code>Preserve(s,s&#39;)</code></pre>
<p>Equivalently:</p>
<pre><code>RC(s) ∧ Endorse(s,m)
→ ∀ P,c. (ownP(s,P)=some(c) → Sat(step(s,m),s,c))</code></pre>
<h3 id="proof">Proof</h3>
<p>By RC-Endorse:</p>
<pre><code>RC(s) ∧ Endorse(s,m) → Adm(s,m)</code></pre>
<p>By definition of <code>Adm</code>:</p>
<pre><code>Adm(s,m) := Preserve(s, step(s,m))</code></pre>
<p>Thus <code>Preserve(s,s')</code> follows directly. ∎</p>
<hr />
<h2 id="trajectory-form-delegation-across-generations">7. Trajectory
Form: Delegation Across Generations</h2>
<p>Most alignment failures are hypothesized to occur over chains of
delegation.</p>
<p>Define endorsed step reachability:</p>
<pre><code>EndStep(s,s&#39;) := ∃ m. Endorse(s,m) ∧ s&#39; = step(s,m)</code></pre>
<p>Let <code>EndReach(s,s')</code> be the reflexive-transitive closure
of <code>EndStep</code>.</p>
<p>Define trajectory preservation anchored at the minting state:</p>
<pre><code>Preserve*(s,s&#39;) := ∀ P,c. ownP(s,P)=some(c) → Sat(s&#39;,s,c)</code></pre>
<h3 id="theorem-trajectory-invariance">Theorem (Trajectory
Invariance)</h3>
<pre><code>RC(s) ∧ EndReach(s,s&#39;) → Preserve*(s,s&#39;)</code></pre>
<p>Any state reachable through a chain of endorsed delegations must
satisfy every commitment minted at the originating state. “My successor
did it” is not a coherent escape hatch under reflective closure.</p>
<hr />
<h2 id="verification-cost-and-vingean-reflection">8. Verification Cost
and Vingean Reflection</h2>
<p>The Delegation Invariance Theorem does <strong>not</strong> assert
that admissibility is decidable, tractable, or cheap.</p>
<p>Determining <code>Adm(s,m)</code> may be undecidable or
computationally infeasible for sufficiently complex successors.
Reflective closure therefore implies a <strong>growth–safety
tradeoff</strong>:</p>
<blockquote>
<p>If an agent cannot prove a successor preserves its commitments, it
cannot coherently endorse that successor.</p>
</blockquote>
<p>This may result in conservative self-modification or stalled
delegation. This is not a defect of the theory. It is the unavoidable
cost of binding commitments under reflection. There is no free lunch:
unbounded delegation without verification collapses reflective
sovereignty.</p>
<hr />
<h2 id="ontological-stability-and-semantic-drift">9. Ontological
Stability and Semantic Drift</h2>
<p>The trajectory theorem assumes that commitments minted at
<code>s</code> remain semantically meaningful at successor states.</p>
<p>This requires either:</p>
<ol type="1">
<li><strong>Ontological stability</strong> of <code>State</code> and
<code>Pred</code>, or</li>
<li>A <strong>verified semantic translation layer</strong> mapping
predicates across state representations.</li>
</ol>
<p>Unchecked ontological drift renders endorsement undefined. Semantic
coherence is therefore a kernel-level requirement, not an external
patch.</p>
<hr />
<h2 id="relation-to-kernel-non-simulability">10. Relation to Kernel
Non-Simulability</h2>
<p>If endorsed delegation could violate prior commitments, those
commitments would be advisory. Advisory commitments admit a simulability
construction identical to the one ruled out by Kernel
Non-Simulability.</p>
<p>Delegation Invariance is therefore not a moral injunction. It is the
temporal extension of the same non-simulability constraint:
<strong>binding authority must bind continuation selection</strong>,
whether across control flow or across time.</p>
<hr />
<h2 id="open-work">11. Open Work</h2>
<ul>
<li>Mechanize the trajectory theorem via induction over
<code>EndReach</code>.</li>
<li>Provide an explicit reduction from advisory commitments to kernel
simulability.</li>
<li>Integrate consent and non-harm invariants once endorsed-succession
invariance is established.</li>
</ul>

    </article>
</body>
</html>
